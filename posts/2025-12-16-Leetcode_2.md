---
title: 随想录#1 二分查找
date: 2025-12-16
category: 学习
tags: [Leetcode, 算法]
---

# 3. 移除元素

***

[27. 移除元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-element/description/)

# 暴力解法

思想是使用两个for循环，在第一个循环完成数组的遍历，遇到符合删除条件的元素后开启第二个for循环完成对该元素的删除（后续元素向前覆盖）

时间复杂度：O(n^2)

## 错误答案：

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        length = len(nums)
        i, j = 0, 0
        for i in range(len(nums)-1):
            if(nums[i] == val):
                for j in range(i + 1, len(nums)):
                    nums[j - 1] = nums[j] #这个地方不能用nums[i] = nums[j]因为i的值在这个循环中不变
                i -= 1
                length -= 1

        return length
```

这里涉及到一个python for循环中的坑，因为python中不能在for循环体内改变循环变量`i`的值，详见坑收集页面

[Python for 循环中 i 值改变问题](https://www.notion.so/Python-for-i-7fae7f4930a548e4b9713f9e7eaf707b?pvs=21)

## 正确答案：

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        ls=len(nums)
        i = 0
        while i < ls:     #用for不能改变i的值
            if nums[i] == val:
                for j in range(i + 1, ls):
                    nums[j - 1] = nums[j]
                ls -= 1
                i -= 1
            i += 1             
        return ls
```

# 双指针法

思想：**一次循环完成两次循环的任务，这个算法设计的很巧妙！结合代码和图片理解**

定义快慢两指针，将两指针看作同时运动，但慢指针本质上不参与循环，同时负责保存最后的位置。

- 如果`快指针的值 ！= val` ，则两指针同时移动。
- 当 `快指针的值==val` 时，慢指针停止移动。快指针动了，慢指针没动，此时再执行`nums[slow] = nums[fast]`，将下一个快指针的值覆盖到当前位置，循环到结束（出来一个符合删除条件的后续的数组元素都要向前移动）。
- 不符合删除条件时，两指针保持同速移动。

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        fast, slow = 0, 0
        for fast in range(len(nums)):
            if(val != nums[fast]):
                nums[slow] = nums[fast]
                slow += 1
        return slow
```

# 暴力解法

思想是使用两个for循环，在第一个循环完成数组的遍历，遇到符合删除条件的元素后开启第二个for循环完成对该元素的删除（后续元素向前覆盖）

时间复杂度：O(n^2)

## 错误答案：

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        length = len(nums)
        i, j = 0, 0
        for i in range(len(nums)-1):
            if(nums[i] == val):
                for j in range(i + 1, len(nums)):
                    nums[j - 1] = nums[j] #这个地方不能用nums[i] = nums[j]因为i的值在这个循环中不变
                i -= 1
                length -= 1

        return length
```

这里涉及到一个python for循环中的坑，因为python中不能在for循环体内改变循环变量`i`的值，详见坑收集页面

[Python for 循环中 i 值改变问题](https://www.notion.so/Python-for-i-7fae7f4930a548e4b9713f9e7eaf707b?pvs=21)

## 正确答案：

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        ls=len(nums)
        i = 0
        while i < ls:     #用for不能改变i的值
            if nums[i] == val:
                for j in range(i + 1, ls):
                    nums[j - 1] = nums[j]
                ls -= 1
                i -= 1
            i += 1             
        return ls
```

# 双指针法

思想：**一次循环完成两次循环的任务，这个算法设计的很巧妙！结合代码和图片理解**

定义快慢两指针，将两指针看作同时运动，但慢指针本质上不参与循环，同时负责保存最后的位置。

- 如果`快指针的值 ！= val` ，则两指针同时移动。
- 当 `快指针的值==val` 时，慢指针停止移动。快指针动了，慢指针没动，此时再执行`nums[slow] = nums[fast]`，将下一个快指针的值覆盖到当前位置，循环到结束（出来一个符合删除条件的后续的数组元素都要向前移动）。
- 不符合删除条件时，两指针保持同速移动。

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        fast, slow = 0, 0
        for fast in range(len(nums)):
            if(val != nums[fast]):
                nums[slow] = nums[fast]
                slow += 1
        return slow
```

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slow_index = 0;
        for (int fast_index = 0; fast_index < nums.size(); fast_index ++){
            if(val != nums[fast_index]){
                nums[slow_index++] = nums[fast_index];
            }
        }
        return slow_index;
    }
};
```

